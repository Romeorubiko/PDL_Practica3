/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package generado;

import java_cup.runtime.*;
import generado.Lexer;
import manual.Variable;
import java.util.ArrayList;
import java.lang.reflect.Array;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import manual.ErrorCheck;
import manual.TypeConvert;

parser code {:
  protected Lexer lexer;
  ArrayList<Variable> variables = new ArrayList<>(); 
  ArrayList<Integer> temp = new ArrayList<>();	
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  ErrorCheck errorCheck = new ErrorCheck();
  symbolFactory = f;
  File file = new File("input1.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal   ENTERO, REAL, FINMIENTRAS, NOT, BOOLEANO, VECTOR, CARACTER
, MIENTRAS, SI, ENTONCES, SINO, FINSI, AND, OR, EQ, SEMI, COMA, PLUS, MINUS, TIMES, EQEQ
, LTEQ, GTEQ, NOTEQ, LT, GT, ASIG, SAL, DIVIDEBY, LPAREN, RPAREN, LBRACK, RBRACK, LCURVY
, RCURVY, ID;
terminal Integer    	INT_NUMBER;       
terminal Float 			DEC_NUMBER;
terminal Boolean		BOOLEAN_LITERAL;
terminal char 			CHAR;
/* Non terminals */
non terminal       		v_exp_list,expr_list, sentencia, sent_decl,sent_uso,sent_flujo,decl_variable,asignacion
,condicional,bucle, operando, blq_sentencias, decl_vector,def_funcion,lista_args
,argumento, uso_funcion, lista_expresiones,keytipo, more_v;

non terminal           	par_neg, impar_neg, plus;
non terminal Integer    e_int, t_int, f_int, p_int;
non terminal Float 		e_float, t_float, f_float, p_float;
non terminal Object 	expresion;
non terminal Boolean  	e_boolean;


/* Precedences */
precedence left AND, OR;
precedence nonassoc GT, LT, EQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDEBY;



/* The grammar rules */
blq_sentencias	::= blq_sentencias sentencia
			| sentencia
			;
sentencia 	::= sent_decl
			| sent_uso
			| sent_flujo
			;
sent_decl 	::= decl_variable SEMI
			| decl_vector SEMI
			;
sent_uso 	::= asignacion SEMI
			| expresion SEMI
			;
sent_flujo 		::= condicional
			| bucle
    		;
asignacion ::= ID:e1 ASIG expresion:e2				{:
														ErrorCheck err = new ErrorCheck();
														TypeConvert conv = new TypeConvert();
														Boolean declarada = false;
														for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1))) {
																declarada = true;
																if (err.asignacion_check(variable.tipo, variable.id, e2, "asig")){
																	if (variable.tipo.equals("REAL")) variable.valor = conv.toReal(e2);
																	else if (variable.tipo.equals("ENTERO")) variable.valor = conv.toInteger(e2);
																	else variable.valor = e2;
 																System.out.println(e1+" = "+e2); 
																}
																break;
															}
														}
													if (!declarada) {
														System.out.println("Error: "+e1+" = "+e2); 
														System.out.println("La variable '"+e1+"' no esta declarada");
													 }
													:}
			|ID:e1 v_exp_list ASIG expresion:e2		{:  
														for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1))){
																int pos = temp.get(0) - 1;
																for(int i = 1 ; i < variable.dimension.length; i++) {
																	int ponderacion = 1;
																	for(int j = 0; j < i ; j++) ponderacion = ponderacion * variable.dimension[j];
																	pos = pos + ponderacion * (temp.get(i)-1); 
																}
																variable.vector[pos] = e2;
																System.out.println(e1+":"+pos+" = "+e2);
																temp.clear();
															}
														}:}
			;    		
expresion	::= e_int:e 							{: RESULT = e;:}
			| e_float:e								{: RESULT = e;:}
			| e_boolean:e 							{: RESULT = e; :}
			;
v_exp_list  ::= LBRACK e_int:e RBRACK				{:temp.add(e);:}
			| v_exp_list LBRACK e_int:e RBRACK		{:temp.add(e);:}
			;
condicional ::= SI expresion ENTONCES blq_sentencias FINSI
			| SI expresion ENTONCES
			blq_sentencias
			SINO
			blq_sentencias
			FINSI									
			;
bucle ::= MIENTRAS expresion blq_sentencias FINMIENTRAS
			;
decl_variable ::= keytipo:k ID:e1 ASIG expresion:e2 {: ErrorCheck err = new ErrorCheck();
													   TypeConvert conv = new TypeConvert();
													if (err.asignacion_check(String.valueOf(k),String.valueOf(e1), e2, "decl")) {
														System.out.println(e1+" = "+e2); 
														if (k.equals("REAL")) variables.add(new Variable(String.valueOf(k),String.valueOf(e1), conv.toReal(e2))); 
														else if (k.equals("INTEGER")) variables.add(new Variable(String.valueOf(k),String.valueOf(e1), conv.toInteger(e2))); 
														else variables.add(new Variable(String.valueOf(k),String.valueOf(e1), e2)); 								
													}
													:}
			| keytipo:k more_v:e1					{: for (Variable variable : variables) {
															if(variable.tipo.equals(String.valueOf('c')))
																variable.tipo = String.valueOf(k);
														}
													:}
			;
more_v ::= more_v COMA ID:e1						{:System.out.println("Declarado: "+e1);variables.add(new Variable(String.valueOf('c'),String.valueOf(e1),null));:}
			| ID:e1									{:System.out.println("Declarado: "+e1);variables.add(new Variable(String.valueOf('c'),String.valueOf(e1),null));:}
			;
keytipo		::= ENTERO								{: RESULT = "ENTERO"; :}
			| REAL									{: RESULT = "REAL"; :}
			| BOOLEANO:e							{: RESULT = "BOOLEANO"; :}
			| CARACTER:e 							{: RESULT = "CARACTER"; :}
			;
decl_vector ::= VECTOR keytipo:k ID:e1 v_exp_list:e2{:	int longitud = 1;
														for (Integer in : temp) longitud = longitud * in;
														if(String.valueOf(k).toUpperCase().equals("ENTERO"))variables.add(new Variable("VECTOR_ENTERO",String.valueOf(e1),new Integer[longitud], (Integer[])temp.toArray(new Integer[0])));
														else if(String.valueOf(k).toUpperCase().equals("REAL"))variables.add(new Variable("VECTOR_REAL",String.valueOf(e1),new Float[longitud], (Integer[])temp.toArray(new Integer[0])));
														else if(String.valueOf(k).toUpperCase().equals("BOOLEANO"))variables.add(new Variable("VECTOR_BOOLEANO",String.valueOf(e1),new Boolean[longitud], (Integer[])temp.toArray(new Integer[0])));
														else if(String.valueOf(k).toUpperCase().equals("CARACTER"))variables.add(new Variable("VECTOR_CARACTER",String.valueOf(e1),new Character[longitud], (Integer[])temp.toArray(new Integer[0])));													
														
														temp.clear();
													:}
			;

			/*
def_funcion ::= FUNCION ID LPAREN lista_args RPAREN SAL KEYTIPO
			LCURVY blq_sentencias RCURVY
			| FUNCION ID LPAREN RPAREN SAL KEYTIPO
			LCURVY blq_sentencias RCURVY
			;
argumento 	::= KEYTIPO ID
			;
uso_funcion ::= ID LPAREN lista_expresiones RPAREN
			;	
*/			
//expresiones

expr_list 	    ::= e_int:e 					{: RESULT = e; :}
				| e_float:e						{: RESULT = e; :}
				;
/*integer*/
e_int 		::=	e_int:e1 PLUS t_int:e2			{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| t_int:e1						{: RESULT = e1;        	:}
				;
				
t_int 		::= t_int:e1 TIMES f_int:e2 		{: RESULT = e1*e2;        :}
				| f_int:e1						{: RESULT = e1;        :}
				;
				
f_int 		::= par_neg INT_NUMBER:e1			{: RESULT = e1;        :}
				| impar_neg INT_NUMBER:e1		{: RESULT = -e1;       :}
				| par_neg p_int:e1				{: RESULT = e1;        :}
				| impar_neg p_int:e1			{: RESULT = -e1;       :}
				| INT_NUMBER:e1					{: RESULT = e1;        :}
				| p_int:e1						{: RESULT = e1;        :}
				| CHAR:e1						{: RESULT = TypeConvert.toInteger(e1);        :}
				;
		
p_int 		::= LPAREN e_int:e1 RPAREN			{: RESULT = e1;        :}
				;
/*float*/
e_float 		::=	e_float:e1 PLUS t_float:e2	{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_float:e2	{: RESULT = e1-e2;        :}
				| e_float:e1 PLUS t_int:e2		{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| e_int:e1 PLUS t_float:e2		{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_float:e2		{: RESULT = e1-e2;        :}
				| t_float:e1					{: RESULT = e1;        	:}
				;
				
t_float 		::= t_float:e1 TIMES f_float:e2 {: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_float:e2{: RESULT = e1/e2;        :}
				| t_float:e1 TIMES f_int:e2 	{: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_int:e2	{: RESULT = e1/e2.floatValue();        :}
				| t_int:e1 TIMES f_float:e2 	{: RESULT = e1*e2;        :}
				| t_int:e1 DIVIDEBY f_float:e2	{: RESULT = e1.floatValue()/e2;        :}
				| t_int:e1 DIVIDEBY f_int:e2	{: RESULT = e1.floatValue()/e2.floatValue();        :}
				| f_float:e1					{: RESULT = e1;        :}
				;
				
f_float 		::=  par_neg DEC_NUMBER:e1		{: RESULT = e1;        :}
				| impar_neg DEC_NUMBER:e1		{: RESULT = -e1;       :}
				| par_neg  p_float:e1			{: RESULT = e1;        :}
				| impar_neg  p_float:e1			{: RESULT = -e1;       :}
				| DEC_NUMBER:e1					{: RESULT = e1;        :}
				| p_float:e1					{: RESULT = e1;        :}
				| ID:e1							{: for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1)))
																RESULT = Float.valueOf(String.valueOf(variable.valor));
														}       :}
				| ID:e1	v_exp_list				{:  
														for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1))){
																int pos = temp.get(0) - 1;
																for(int i = 1 ; i < variable.dimension.length; i++) {
																	int ponderacion = 1;
																	for(int j = 0; j < i ; j++) ponderacion = ponderacion * variable.dimension[j];
																	pos = pos + ponderacion * (temp.get(i)-1); 
																}
																temp.clear();
																System.out.println(e1+":"+pos+"("+variable.vector[pos]+")");
																RESULT = Float.valueOf(String.valueOf(variable.vector[pos]));
															}
														}:}
				;
				
p_float 		::= LPAREN e_float:e1 RPAREN	{: RESULT = e1;        :}
				;  
e_boolean		::=/* e_int:e1 EQEQ e_int:e2{: RESULT = (e1 == e2);        :}
				| e_int:e1 LTEQ e_int:e2	{: RESULT = (((int)e1) <= ((int)e2));        :}
				| e_int:e1 GTEQ e_int:e2	{: RESULT = (((int)e1) >= ((int)e2));        :}
				| e_int:e1 NOTEQ e_int:e2	{: RESULT = (((int)e1) != ((int)e2));        :}
				| e_int:e1 LT e_int:e2	{: RESULT = (((int)e1) < ((int)e2));        :}
				| e_int:e1 GT e_int:e2	{: RESULT = (((int)e1) > ((int)e2));        :}

				| e_float:e1 EQEQ e_float:e2{: RESULT = (e1 == e2);        :}
				| e_float:e1 LTEQ e_float:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_float:e1 GTEQ e_float:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_float:e1 NOTEQ e_float:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_float:e1 LT e_float:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_float:e1 GT e_float:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
				
				| e_float:e1 EQEQ e_int:e2{: RESULT = (e1 == e2.floatValue());        :}
				| e_float:e1 LTEQ e_int:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_float:e1 GTEQ e_int:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_float:e1 NOTEQ e_int:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_float:e1 LT e_int:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_float:e1 GT e_int:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
				
				| e_int:e1 EQEQ e_float:e2{: RESULT = (e1.floatValue() == e2);        :}
				| e_int:e1 LTEQ e_float:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_int:e1 GTEQ e_float:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_int:e1 NOTEQ e_float:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_int:e1 LT e_float:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_int:e1 GT e_float:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
*/
					expr_list:e1 EQEQ expr_list:e2{: RESULT = (e1 == e2);        :}
				| expr_list:e1 LTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) <= (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 GTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) >= (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 NOTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) != (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 LT expr_list:e2	{: RESULT = ((Float.valueOf(String.valueOf(e1))) < (Float.valueOf(String.valueOf(e2))));		:}
				| expr_list:e1 GT expr_list:e2	{: RESULT = ((Float.valueOf(String.valueOf(e1))) > (Float.valueOf(String.valueOf(e2))));        :}

				| e_boolean:e1 OR  e_boolean:e2	{: RESULT = (((boolean)e1) || ((boolean)e2));        :}
				| e_boolean:e1 AND  e_boolean:e2{: RESULT = (((boolean)e1) && ((boolean)e2));        :}
				| NOT  e_boolean:e1				{: RESULT = !(boolean)e1;        :}
				| BOOLEAN_LITERAL:e1			{: RESULT = e1;        :}
				;				
//sustitucion de uminus				      
par_neg 		::= MINUS MINUS
				| par_neg MINUS MINUS
				| PLUS
				| par_neg PLUS
				| MINUS plus MINUS
				| par_neg MINUS plus MINUS
				;
				
impar_neg		::= MINUS
				| MINUS plus
				| par_neg MINUS
				| par_neg MINUS plus					
				;					   
				
plus 			::= plus PLUS
				| PLUS
				;					
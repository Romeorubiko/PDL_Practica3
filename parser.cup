/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package generado;

import java_cup.runtime.*;
import generado.Lexer;
import manual.Variable;
import java.util.ArrayList;
import java.lang.reflect.Array;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
  ArrayList<Variable> variables = new ArrayList<>(); 
  ArrayList<Integer> temp = new ArrayList<>();	
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input1.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal   ENTERO, REAL, FINMIENTRAS, NOT, BOOLEANO, VECTOR, CARACTER
, MIENTRAS, SI, ENTONCES, SINO, FINSI, AND, OR, EQ, SEMI, COMA, PLUS, MINUS, TIMES, EQEQ
, LTEQ, GTEQ, NOTEQ, LT, GT, ASIG, SAL, DIVIDEBY, LPAREN, RPAREN, LBRACK, RBRACK, LCURVY
, RCURVY, ID;
terminal Integer    	INT_NUMBER;       
terminal Float 			DEC_NUMBER;
terminal Boolean		BOOLEAN_LITERAL;
terminal char 			CHAR;
/* Non terminals */
non terminal       		v_exp_list,expr_list, sentencia, sent_decl,sent_uso,sent_flujo,decl_variable,asignacion
,condicional,bucle, operando, blq_sentencias, decl_vector,def_funcion,lista_args
,argumento, uso_funcion, lista_expresiones,keytipo, more_v;

non terminal           	par_neg, impar_neg, plus;
non terminal Integer    e_int, t_int, f_int, p_int;
non terminal Float 		e_float, t_float, f_float, p_float;
non terminal Object 	expresion;
non terminal Boolean  	e_boolean;


/* Precedences */
precedence left AND, OR;
precedence nonassoc GT, LT, EQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDEBY;

/* The grammar rules */
blq_sentencias	::= blq_sentencias sentencia
			| sentencia
			;
sentencia 	::= sent_decl
			| sent_uso
			| sent_flujo
			;
sent_decl 	::= decl_variable SEMI
			| decl_vector SEMI
			;
sent_uso 	::= asignacion SEMI
			| expresion SEMI
			;
sent_flujo 		::= condicional
			| bucle
    		;
asignacion ::= ID:e1 ASIG expresion:e2				{: System.out.println(e1+" = "+e2); 
														for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1)))
																variable.valor = e2;
														}:}
			|ID:e1 v_exp_list ASIG expresion:e2		
			;    		
expresion	::= e_int:e 							{: RESULT = e;:}
			| e_float:e								{: RESULT = e;:}
			| e_boolean:e 							{: RESULT = e; :}
			| CHAR:e 								{: RESULT = e; :}
			;
v_exp_list  ::= LBRACK e_int:e RBRACK				{:temp.add(e);:}
			| v_exp_list LBRACK e_int:e RBRACK		{:temp.add(e);:}
			;
condicional ::= SI expresion ENTONCES blq_sentencias FINSI
			| SI expresion ENTONCES
			blq_sentencias
			SINO
			blq_sentencias
			FINSI									
			;
bucle ::= MIENTRAS expresion blq_sentencias FINMIENTRAS
			;
decl_variable ::= keytipo:k ID:e1 ASIG expresion:e2 {: System.out.println(e1+" = "+e2); variables.add(new Variable(String.valueOf(k),String.valueOf(e1),e2)); :}
			| keytipo:k more_v:e1					{: for (Variable variable : variables) {
															if(variable.tipo.equals(String.valueOf('c')))
																variable.tipo = String.valueOf(k);
														}
													:}
			;
more_v ::= more_v COMA ID:e1						{:System.out.println("Declarado: "+e1);variables.add(new Variable(String.valueOf('c'),String.valueOf(e1),null));:}
			| ID:e1									{:System.out.println("Declarado: "+e1);variables.add(new Variable(String.valueOf('c'),String.valueOf(e1),null));:}
			;
keytipo		::= ENTERO								{: RESULT = "ENTERO"; :}
			| REAL									{: RESULT = "REAL"; :}
			| BOOLEANO:e							{: RESULT = "BOOLEANO"; :}
			| CARACTER:e 							{: RESULT = "CARACTER"; :}
			;
decl_vector ::= VECTOR keytipo:k ID:e1 v_exp_list:e2{:	if(String.valueOf(k).equals("ENTERO"))variables.add(new Variable("VECTOR_ENTERO",String.valueOf(e1),Array.newInstance(Integer.class, temp.stream().mapToInt(i -> i).toArray())));													
														else if(String.valueOf(k).equals("REAL"))variables.add(new Variable("VECTOR_REAL",String.valueOf(e1),Array.newInstance(Float.class, temp.stream().mapToInt(i -> i).toArray())));
														else if(String.valueOf(k).equals("BOOLEANO"))variables.add(new Variable("VECTOR_BOOLEANO",String.valueOf(e1),Array.newInstance(Boolean.class, temp.stream().mapToInt(i -> i).toArray())));
														else if(String.valueOf(k).equals("CARACTER"))variables.add(new Variable("VECTOR_CARACTER",String.valueOf(e1),Array.newInstance(Character.class, temp.stream().mapToInt(i -> i).toArray())));
														temp.clear();
													:}
			;

			/*
def_funcion ::= FUNCION ID LPAREN lista_args RPAREN SAL KEYTIPO
			LCURVY blq_sentencias RCURVY
			| FUNCION ID LPAREN RPAREN SAL KEYTIPO
			LCURVY blq_sentencias RCURVY
			;
argumento 	::= KEYTIPO ID
			;
uso_funcion ::= ID LPAREN lista_expresiones RPAREN
			;	
*/			
//expresiones

expr_list 	::= e_int:e 						{: RESULT = e; :}
				| e_float:e						{: RESULT = e; :}
				;
/*integer*/
e_int 		::=	e_int:e1 PLUS t_int:e2			{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| t_int:e1						{: RESULT = e1;        	:}
				;
				
t_int 		::= t_int:e1 TIMES f_int:e2 		{: RESULT = e1*e2;        :}
				| f_int:e1						{: RESULT = e1;        :}
				;
				
f_int 		::= par_neg INT_NUMBER:e1			{: RESULT = e1;        :}
				| impar_neg INT_NUMBER:e1		{: RESULT = -e1;       :}
				| par_neg p_int:e1				{: RESULT = e1;        :}
				| impar_neg p_int:e1			{: RESULT = -e1;       :}
				| INT_NUMBER:e1					{: RESULT = e1;        :}
				| p_int:e1						{: RESULT = e1;        :}
				;
		
p_int 		::= LPAREN e_int:e1 RPAREN			{: RESULT = e1;        :}
				;
/*float*/
e_float 		::=	e_float:e1 PLUS t_float:e2	{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_float:e2	{: RESULT = e1-e2;        :}
				| e_float:e1 PLUS t_int:e2		{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| e_int:e1 PLUS t_float:e2		{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_float:e2		{: RESULT = e1-e2;        :}
				| t_float:e1					{: RESULT = e1;        	:}
				;
				
t_float 		::= t_float:e1 TIMES f_float:e2 {: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_float:e2{: RESULT = e1/e2;        :}
				| t_float:e1 TIMES f_int:e2 	{: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_int:e2	{: RESULT = e1/e2.floatValue();        :}
				| t_int:e1 TIMES f_float:e2 	{: RESULT = e1*e2;        :}
				| t_int:e1 DIVIDEBY f_float:e2	{: RESULT = e1.floatValue()/e2;        :}
				| t_int:e1 DIVIDEBY f_int:e2	{: RESULT = e1.floatValue()/e2.floatValue();        :}
				| f_float:e1					{: RESULT = e1;        :}
				;
				
f_float 		::=  par_neg DEC_NUMBER:e1		{: RESULT = e1;        :}
				| impar_neg DEC_NUMBER:e1		{: RESULT = -e1;        :}
				| par_neg  p_float:e1			{: RESULT = e1;        :}
				| impar_neg  p_float:e1			{: RESULT = -e1;        :}
				| DEC_NUMBER:e1					{: RESULT = e1;        :}
				| p_float:e1					{: RESULT = e1;        :}
				| ID:e1							{: for (Variable variable : variables) {
															if(variable.id.equals(String.valueOf(e1)))
																RESULT = Float.valueOf(String.valueOf(variable.valor));
														}       :}
				;
				
p_float 		::= LPAREN e_float:e1 RPAREN	{: RESULT = e1;        :}
				;  
e_boolean		::=/* e_int:e1 EQEQ e_int:e2{: RESULT = (e1 == e2);        :}
				| e_int:e1 LTEQ e_int:e2	{: RESULT = (((int)e1) <= ((int)e2));        :}
				| e_int:e1 GTEQ e_int:e2	{: RESULT = (((int)e1) >= ((int)e2));        :}
				| e_int:e1 NOTEQ e_int:e2	{: RESULT = (((int)e1) != ((int)e2));        :}
				| e_int:e1 LT e_int:e2	{: RESULT = (((int)e1) < ((int)e2));        :}
				| e_int:e1 GT e_int:e2	{: RESULT = (((int)e1) > ((int)e2));        :}

				| e_float:e1 EQEQ e_float:e2{: RESULT = (e1 == e2);        :}
				| e_float:e1 LTEQ e_float:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_float:e1 GTEQ e_float:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_float:e1 NOTEQ e_float:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_float:e1 LT e_float:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_float:e1 GT e_float:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
				
				| e_float:e1 EQEQ e_int:e2{: RESULT = (e1 == e2.floatValue());        :}
				| e_float:e1 LTEQ e_int:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_float:e1 GTEQ e_int:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_float:e1 NOTEQ e_int:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_float:e1 LT e_int:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_float:e1 GT e_int:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
				
				| e_int:e1 EQEQ e_float:e2{: RESULT = (e1.floatValue() == e2);        :}
				| e_int:e1 LTEQ e_float:e2	{: RESULT = (((float)e1) <= ((float)e2));        :}
				| e_int:e1 GTEQ e_float:e2	{: RESULT = (((float)e1) >= ((float)e2));        :}
				| e_int:e1 NOTEQ e_float:e2	{: RESULT = (((float)e1) != ((float)e2));        :}
				| e_int:e1 LT e_float:e2	{: RESULT = (((float)e1) < ((float)e2));        :}
				| e_int:e1 GT e_float:e2	{: RESULT = (((float)e1) > ((float)e2));        :}
*/
					expr_list:e1 EQEQ expr_list:e2{: RESULT = (e1 == e2);        :}
				| expr_list:e1 LTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) <= (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 GTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) >= (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 NOTEQ expr_list:e2{: RESULT = ((Float.valueOf(String.valueOf(e1))) != (Float.valueOf(String.valueOf(e2))));   :}
				| expr_list:e1 LT expr_list:e2	{: RESULT = ((Float.valueOf(String.valueOf(e1))) < (Float.valueOf(String.valueOf(e2))));		:}
				| expr_list:e1 GT expr_list:e2	{: RESULT = ((Float.valueOf(String.valueOf(e1))) > (Float.valueOf(String.valueOf(e2))));        :}

				| e_boolean:e1 OR  e_boolean:e2	{: RESULT = (((boolean)e1) || ((boolean)e2));        :}
				| e_boolean:e1 AND  e_boolean:e2{: RESULT = (((boolean)e1) && ((boolean)e2));        :}
				| NOT  e_boolean:e1				{: RESULT = !(boolean)e1;        :}
				| BOOLEAN_LITERAL:e1			{: RESULT = e1;        :}
				;				
//sustitucion de uminus				      
par_neg 		::= MINUS MINUS
				| par_neg MINUS MINUS
				| PLUS
				| par_neg PLUS
				| MINUS plus MINUS
				| par_neg MINUS plus MINUS
				;
				
impar_neg		::= MINUS
				| MINUS plus
				| par_neg MINUS
				| par_neg MINUS plus					
				;					   
				
plus 			::= plus PLUS
				| PLUS
				;					